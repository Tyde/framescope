// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/danielthiem/Documents/git/monitor_cpu/main.go:1:1
package main

/*
#cgo darwin CFLAGS: -x objective-c -fobjc-arc
#cgo darwin LDFLAGS: -framework Cocoa
#include <stdlib.h>
#include <libproc.h>
#include <sys/resource.h>
#include <sys/proc_info.h>
#include "cocoa_bridge.h"

static int listPIDs(pid_t *buffer, int buffersize) {
	return proc_listallpids(buffer, buffersize);
}

static int pidRusage(int pid, struct rusage_info_v2 *info) {
	return proc_pid_rusage(pid, RUSAGE_INFO_V2, (rusage_info_t *)info);
}

static int pidPath(int pid, char *buffer, uint32_t size) {
	return proc_pidpath(pid, buffer, size);
}

static int pidName(int pid, char *buffer, uint32_t size) {
	return proc_name(pid, buffer, size);
}
*/
import _ "unsafe"

import (
	"context"
	"fmt"
	"runtime"
	"sort"
	"strings"
	"sync"
	"time"
	"unsafe"
)

type processSample struct {
	CPUSeconds float64
	Command    string
}

type resultRow struct {
	PID     int
	Diff    float64
	Command string
}

type monitorState struct {
	mu         sync.Mutex
	running    bool
	hideSmall  bool
	hidePaths  bool
	frameIndex int
	runID      int64
	cancel     context.CancelFunc
}

var state = &monitorState{
	hideSmall: true,
	hidePaths: false,
}

func main() {
	runtime.LockOSThread()
	( /*line :69:2*/_Cfunc_RunApp /*line :69:9*/)()
}

//export GoStartMonitoring
func GoStartMonitoring(frameSeconds  /*line :73:37*/_Ctype_double /*line :73:45*/) {
	interval := float64(frameSeconds)
	if interval <= 0 {
		postError(0, "Frame length must be greater than zero seconds.")
		return
	}

	state.mu.Lock()
	if state.cancel != nil {
		state.cancel()
		state.cancel = nil
	}
	ctx, cancel := context.WithCancel(context.Background())
	state.runID++
	runID := state.runID
	state.cancel = cancel
	state.running = true
	state.frameIndex = 1
	state.mu.Unlock()

	go runMonitor(ctx, runID, interval)
}

//export GoStopMonitoring
func GoStopMonitoring() {
	state.mu.Lock()
	cancel := state.cancel
	state.runID++
	state.cancel = nil
	state.running = false
	state.mu.Unlock()

	if cancel != nil {
		cancel()
	}

	postUpdate(0, "Monitoring stopped.", "Press Start to begin a new measurement loop.")
}

//export GoSetHideSmall
func GoSetHideSmall(enabled  /*line :113:29*/_Ctype_int /*line :113:34*/) {
	state.mu.Lock()
	state.hideSmall = enabled != 0
	state.mu.Unlock()
}

//export GoSetHidePaths
func GoSetHidePaths(enabled  /*line :120:29*/_Ctype_int /*line :120:34*/) {
	state.mu.Lock()
	state.hidePaths = enabled != 0
	state.mu.Unlock()
}

func runMonitor(ctx context.Context, runID int64, frameSeconds float64) {
	baseline, err := snapshot()
	if err != nil {
		postError(runID, fmt.Sprintf("Initial snapshot failed: %v", err))
		stopFromWorker(runID)
		return
	}

	frameDuration := time.Duration(frameSeconds * float64(time.Second))
	frameStart := time.Now()
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	postUpdate(
		runID,
		fmt.Sprintf("Running. Frame 1 of %.1fs started.", frameSeconds),
		"Collecting initial samples...",
	)

	for {
		select {
		case <-ctx.Done():
			return
		case now := <-ticker.C:
			current, err := snapshot()
			if err != nil {
				postError(runID, fmt.Sprintf("Snapshot failed: %v", err))
				continue
			}

			results := computeResults(baseline, current)
			status := buildStatus(frameSeconds, frameStart, now, results)
			postUpdate(runID, status, renderTable(results))

			if now.Sub(frameStart) >= frameDuration {
				state.mu.Lock()
				if !state.running {
					state.mu.Unlock()
					return
				}
				state.frameIndex++
				frameIndex := state.frameIndex
				state.mu.Unlock()

				baseline = current
				frameStart = now
				postUpdate(
					runID,
					fmt.Sprintf("Frame %d started. Length %.1fs.", frameIndex, frameSeconds),
					renderTable(nil),
				)
			}
		}
	}
}

func stopFromWorker(runID int64) {
	state.mu.Lock()
	if state.runID != runID {
		state.mu.Unlock()
		return
	}
	state.running = false
	state.cancel = nil
	state.mu.Unlock()
}

func snapshot() (map[int]processSample, error) {
	pids, err := listPIDs()
	if err != nil {
		return nil, err
	}

	results := make(map[int]processSample, len(pids))
	for _, pid := range pids {
		if pid <= 0 {
			continue
		}

		var usage  /*line :205:13*/_Ctype_struct_rusage_info_v2 /*line :205:36*/
		if ( /*line :206:6*/_Cfunc_pidRusage /*line :206:16*/)( /*line :206:18*/_Ctype_int /*line :206:23*/(pid), &usage) != 0 {
			continue
		}

		command := processCommand(pid)
		if command == "" {
			command = "<unknown>"
		}

		totalCPU := float64(usage.ri_user_time+usage.ri_system_time) / float64(time.Second)
		results[pid] = processSample{
			CPUSeconds: totalCPU,
			Command:    command,
		}
	}

	return results, nil
}

func listPIDs() ([]int, error) {
	size := 2048
	for {
		pids := make([] /*line :228:18*/_Ctype_pid_t /*line :228:25*/, size)
		written := ( /*line :229:14*/_Cfunc_listPIDs /*line :229:23*/)(
			(* /*line :230:6*/_Ctype_pid_t /*line :230:13*/)(unsafe.Pointer(&pids[0])),
			 /*line :231:4*/_Ctype_int /*line :231:9*/(len(pids))* /*line :231:21*/_Ctype_int /*line :231:26*/(unsafe.Sizeof(pids[0])),
		)
		if written < 0 {
			return nil, fmt.Errorf("proc_listallpids failed")
		}
		if int(written) < len(pids) {
			out := make([]int, 0, written)
			for _, pid := range pids[:written] {
				out = append(out, int(pid))
			}
			return out, nil
		}
		size *= 2
	}
}

func processCommand(pid int) string {
	pathBuf := make([] /*line :248:20*/_Ctype_char /*line :248:26*/, ( /*line :248:28*/_Ciconst_PROC_PIDPATHINFO_MAXSIZE /*line :248:53*/))
	if ( /*line :249:5*/_Cfunc_pidPath /*line :249:13*/)( /*line :249:15*/_Ctype_int /*line :249:20*/(pid), &pathBuf[0],  /*line :249:40*/_Ctype_uint32_t /*line :249:50*/(len(pathBuf))) > 0 {
		return ( /*line :250:10*/_Cfunc_GoString /*line :250:19*/)(&pathBuf[0])
	}

	nameBuf := make([] /*line :253:20*/_Ctype_char /*line :253:26*/, 1024)
	if ( /*line :254:5*/_Cfunc_pidName /*line :254:13*/)( /*line :254:15*/_Ctype_int /*line :254:20*/(pid), &nameBuf[0],  /*line :254:40*/_Ctype_uint32_t /*line :254:50*/(len(nameBuf))) > 0 {
		return ( /*line :255:10*/_Cfunc_GoString /*line :255:19*/)(&nameBuf[0])
	}

	return ""
}

func computeResults(initial, current map[int]processSample) []resultRow {
	rows := make([]resultRow, 0, len(initial))
	for pid, before := range initial {
		after, ok := current[pid]
		if !ok {
			continue
		}

		diff := after.CPUSeconds - before.CPUSeconds
		if diff < 0 {
			continue
		}

		rows = append(rows, resultRow{
			PID:     pid,
			Diff:    diff,
			Command: before.Command,
		})
	}

	sort.Slice(rows, func(i, j int) bool {
		if rows[i].Diff == rows[j].Diff {
			return rows[i].PID < rows[j].PID
		}
		return rows[i].Diff > rows[j].Diff
	})

	return rows
}

func buildStatus(frameSeconds float64, frameStart, now time.Time, rows []resultRow) string {
	state.mu.Lock()
	frameIndex := state.frameIndex
	hideSmall := state.hideSmall
	state.mu.Unlock()

	elapsed := now.Sub(frameStart).Seconds()
	if elapsed < 0 {
		elapsed = 0
	}
	remaining := frameSeconds - elapsed
	if remaining < 0 {
		remaining = 0
	}

	visibleRows := len(rows)
	if hideSmall {
		visibleRows = 0
		for _, row := range rows {
			if row.Diff >= 1 {
				visibleRows++
			}
		}
	}

	return fmt.Sprintf(
		"Running. Frame %d | length %.1fs | elapsed %.1fs | remaining %.1fs | %d visible processes",
		frameIndex,
		frameSeconds,
		elapsed,
		remaining,
		visibleRows,
	)
}

func renderTable(rows []resultRow) string {
	state.mu.Lock()
	hideSmall := state.hideSmall
	hidePaths := state.hidePaths
	state.mu.Unlock()

	filtered := make([]resultRow, 0, len(rows))
	for _, row := range rows {
		if hideSmall && row.Diff < 1 {
			continue
		}
		filtered = append(filtered, row)
	}

	if len(filtered) == 0 {
		return " PID      Raw(s)   CPU Time     Command\n\n No processes match the current filters yet."
	}

	var b strings.Builder
	b.WriteString(" PID      Raw(s)   CPU Time     Command\n")
	b.WriteString(" -----------------------------------------------")

	limit := len(filtered)
	if limit > 100 {
		limit = 100
	}

	for i := 0; i < limit; i++ {
		row := filtered[i]
		command := row.Command
		if hidePaths {
			command = baseCommand(command)
		}
		command = truncate(command, 100)

		fmt.Fprintf(
			&b,
			"\n %-8d %-8.1f %-12s %s",
			row.PID,
			row.Diff,
			formatDuration(row.Diff),
			command,
		)
	}

	if len(filtered) > limit {
		fmt.Fprintf(&b, "\n\n Showing top %d of %d rows.", limit, len(filtered))
	}

	return b.String()
}

func baseCommand(command string) string {
	fields := strings.Fields(command)
	if len(fields) == 0 {
		return command
	}
	parts := strings.Split(fields[0], "/")
	return parts[len(parts)-1]
}

func truncate(value string, width int) string {
	if len(value) <= width {
		return value
	}
	if width <= 3 {
		return value[:width]
	}
	return value[:width-3] + "..."
}

func formatDuration(seconds float64) string {
	total := int(seconds)
	hours := total / 3600
	minutes := (total % 3600) / 60
	secs := total % 60
	return fmt.Sprintf("%02d:%02d:%02d", hours, minutes, secs)
}

func postUpdate(runID int64, status, table string) {
	if !isCurrentRun(runID) {
		return
	}
	cStatus := ( /*line :409:13*/_Cfunc_CString /*line :409:21*/)(status)
	cTable := ( /*line :410:12*/_Cfunc_CString /*line :410:20*/)(table)
	( /*line :411:2*/_Cfunc_UpdateResults /*line :411:16*/)(cStatus, cTable)
	func() { _cgo0 := /*line :412:9*/unsafe.Pointer(cStatus); _cgoCheckPointer(_cgo0, nil); /*line :412:33*/_Cfunc_free(_cgo0); }()
	func() { _cgo0 := /*line :413:9*/unsafe.Pointer(cTable); _cgoCheckPointer(_cgo0, nil); /*line :413:32*/_Cfunc_free(_cgo0); }()
}

func postError(runID int64, message string) {
	if !isCurrentRun(runID) {
		return
	}
	cMessage := ( /*line :420:14*/_Cfunc_CString /*line :420:22*/)(message)
	( /*line :421:2*/_Cfunc_ShowErrorMessage /*line :421:19*/)(cMessage)
	func() { _cgo0 := /*line :422:9*/unsafe.Pointer(cMessage); _cgoCheckPointer(_cgo0, nil); /*line :422:34*/_Cfunc_free(_cgo0); }()
}

func isCurrentRun(runID int64) bool {
	if runID == 0 {
		return true
	}
	state.mu.Lock()
	defer state.mu.Unlock()
	return state.runID == runID
}
